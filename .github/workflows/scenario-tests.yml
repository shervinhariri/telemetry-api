name: scenario-tests
on:
  push:
    branches: [ main, 'fix/**' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  e2e:
    runs-on: ubuntu-latest
    env:
      API_KEY: TEST_ADMIN_KEY
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Build image (no cache)
        run: docker build --pull --no-cache -t telemetry-api:build .

      - name: Run API container (map host 8080 â†’ container 80)
        run: |
          docker rm -f telemetry-api 2>/dev/null || true
          docker run -d --name telemetry-api \
            -p 8080:80 \
            -e API_KEY=TEST_ADMIN_KEY \
            -e USER_API_KEY="***" \
            -e TELEMETRY_SEED_KEYS="" \
            telemetry-api:build

      # Discover a working health endpoint (prefers authenticated /api/health)
      - name: Discover health endpoint
        shell: bash
        env:
          API_KEY: TEST_ADMIN_KEY
        run: |
          set -euo pipefail
          API="http://localhost:8080"
          AUTH=(-H "x-api-key: ${API_KEY}")
          CANDIDATES=(/api/health /api/healthz /health /healthz /v1/health /v1/healthz /readyz /livez /ready /live /)
          # Try OpenAPI first, if available
          HPATH=""
          if curl -sf "${AUTH[@]}" "$API/openapi.json" -o openapi.json; then
            HPATH=$(python - <<'PY'
          import json,sys,re
          d=json.load(open("openapi.json"))
          for p in d.get("paths",{}).keys():
              if re.search(r"/(api/)?healthz?$", p):
                  print(p); break
          PY
          )
            if [ -n "${HPATH}" ]; then
              echo "Discovered health path via OpenAPI: ${HPATH}"
              echo "HEALTH_PATH=${HPATH}" >> "$GITHUB_ENV"
              exit 0
            fi
          fi
          # Probe known candidates
          for p in "${CANDIDATES[@]}"; do
            code=$(curl -s -o /dev/null -w '%{http_code}' "${AUTH[@]}" "$API$p" || true)
            echo "$p -> $code"
            if [ "$code" = "200" ]; then
              echo "HEALTH_PATH=$p" >> "$GITHUB_ENV"
              exit 0
            fi
          done
          echo "::error::Could not find a working health endpoint"
          exit 1

      # Wait for API to be healthy at the discovered path
      - name: Wait for API to be healthy (authenticated)
        if: ${{ env.HEALTH_PATH != '' }}
        shell: bash
        env:
          API_KEY: TEST_ADMIN_KEY
        run: |
          set -euo pipefail
          URL="http://localhost:8080${HEALTH_PATH}"
          echo "Probing $URL"
          for i in {1..120}; do
            code=$(curl -s -o /dev/null -w '%{http_code}' -H "x-api-key: ${API_KEY}" "$URL" || true)
            if [ "$code" = "200" ]; then
              echo "API is healthy at $URL"
              exit 0
            fi
            sleep 1
          done
          echo "API never became healthy at $URL (last status: $code)"
          echo "---- debug response ----"
          curl -i -H "x-api-key: ${API_KEY}" "$URL" || true
          echo "---- docker logs (telemetry-api) ----"
          docker logs --tail=300 telemetry-api || true
          exit 1

      - name: Sanity check container
        run: |
          docker exec telemetry-api python -c "import sqlite3; print('sqlite3 OK')"
          docker exec telemetry-api python -c "from app.main import app; print('app OK')"
          # Verify we're using the locally built image
          docker exec telemetry-api ls -la /app/app/api/
          docker exec telemetry-api python -c "import app.api; print('app.api package OK')"

      - name: DB check (verify scopes format)
        run: |
          docker exec telemetry-api bash -lc 'python - <<"PY"
          from sqlalchemy import create_engine, text
          import os, json, time
          db=os.getenv("DB_URL","sqlite:////data/telemetry.db")
          e=create_engine(db, future=True)
          
          # Wait for api_keys table to exist
          max_retries = 10
          for attempt in range(max_retries):
              try:
                  with e.connect() as c:
                      # First check what tables exist
                      tables = c.execute(text("SELECT name FROM sqlite_master WHERE type=:type"), {"type": "table"}).all()
                      print(f"Available tables: {[t[0] for t in tables]}")
                      
                      rows=c.execute(text("select key_id, scopes from api_keys limit 3;")).all()
                      print("DB scopes check:")
                      for row in rows:
                          print(f"  {row[0]}: {row[1]}")
                      break
              except Exception as exc:
                  if attempt < max_retries - 1:
                      print(f"Waiting for api_keys table (attempt {attempt + 1}/{max_retries})...")
                      time.sleep(2)
                  else:
                      print(f"Failed to find api_keys table after {max_retries} attempts")
                      raise
          PY'

      # Run tests against the running container
      - name: Run tests against container
        env:
          API_BASE_URL: http://localhost:8080
          API_KEY: TEST_ADMIN_KEY
        run: |
          # Wait for API to be ready
          for i in $(seq 1 60); do
            curl -sf "${API_BASE_URL}/v1/health" && break || sleep 1
          done
          # Run tests using HTTP-only approach
          python -m pytest tests/ -v

      - name: Scenario tester
        env:
          API_BASE_URL: http://localhost:8080
          API_KEY: TEST_ADMIN_KEY
        run: |
          python tools/scenario_tester.py | tee scenario_report.json
          echo "---- Summary ----"
          jq '.results[] | {scenario, status, ok}' scenario_report.json

      - name: Show logs on failure
        if: failure()
        run: |
          docker ps -a
          docker logs --tail=200 telemetry-api || true
          curl -v -H "x-api-key: TEST_ADMIN_KEY" http://localhost:8080/health || true

      - name: Upload report artifact
        uses: actions/upload-artifact@v4
        with:
          name: scenario-report
          path: scenario_report.json


